

棋盘格局：左下角为原点，坐标为0,0，我需要最外面一圈作为边界，所以棋盘的实际大小为BoardSize + 2
五子棋的逻辑完成了，接下来开始写AI的决策树算法
晚安
Ai和Board或者Game的接口实现
Ai的决策树实现
新年新气象，准备去图书馆了

System Pause改成别的
现在棋盘的框架都搞好了，差不多可以开始准备着手开始具体实现Ai了
决策树对棋盘的接口调用 {
	由Ai总类来进行控制，具体会给决策树棋盘，然后让它根据需要去调用棋盘的具体方法;
}

第一级的Ai已经完成了，目前测试效果尚可，开始准备下一阶段的Ai
ScoreJudger判分给出十个最佳选项，Tree记录一下，开始依次落子，然后递归，所以要有个层数来限制这个递归（先不写剪枝算法）


判断有问题，落子总是集中在一点

选落子解决了，现在要开始创建决策树并且给出最优解（先少看几步，这样就不用剪枝了）

又卡在生成树这个地方了，爷爷家太吵了，而且我现在心不太静，算了，先放在这，回去 再写吧。

形式判分有些小问题，但是不影响大局，还是不知道为什么剪枝没有效果，要去爷爷家吃午饭，所以先到这里吧

诡异的落子，总是要隔着一个子去落，不想看了，玩会游戏，等会再继续吧

剪枝写错了，Max 和 Min 以及分数最值的逻辑还是不清晰

初步测试完成，但是速度太慢，瓶颈是Judger的GetEachScore，调用的多，而且遍历麻烦，正在想新的打分算法
但是目前不排除决策树生成有问题

暂时结束，目前已知可以改进的地方有：新的打分算法，决策树的生成肯定有问题，但是没有系统的测试方法，所以没有办法评定这个Ai的棋力

算法更新，可以通过打表算分数，算分时只要把当前情况和表对应就行了
具体实现：从EachScore开始。往四边搜索直到搜索到阻挡，然后自动生成特征序列去打好的表里寻找
特征序列生成和对应规则：四个方向搜索，将左右结果分别储存并以此来查找分数（因为不用在这十个位置上反复横移并且计算个数，所以会更加省时）
所以打表的结果只要用二维数组储存起来就可以了。如 ooxx*xxxo(x表示己方落子，o表示空位，*为待测位)，
它的查分编号就是0*2^0 + 0*2^1 + 1*2^2 + 1*2^3 + 1*2^4 + 1*2^5 + 1*2^6 + 0*2^7，
所以用2^8 = 256就可以储存了
先生成分数表
判分好像是正确的，但是在试落子的时候总是落在有子的地方
为什么中键调用的EachScore就是一样的效果
但是左键由Ai来Judge的时候就不一样了呢？还各种毛病
检查得到打表得到的结果和原来的算法大部分相同，但有部分不一样
正在解决
代码改的一团糟，不过不要紧，回去先把打表的问题解决了，然后重构一下就好了











10

9

8

7

6

5

4

3

2                     S1

1	       S1         S2         S3

0  Ai  S1  S2 S3 | S1 S2 S3 | S1 S2 S3 | 